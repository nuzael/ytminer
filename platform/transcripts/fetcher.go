package transcripts

import (
	"context"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// Transcript represents a parsed transcript text for a given video and language.
type Transcript struct {
	VideoID          string
	Language         string
	Source           string // "timedtext" or "cache"
	HasAutoGenerated bool
	Text             string
	FetchedAt        time.Time
}

type timedTextResponse struct {
	XMLName xml.Name      `xml:"transcript"`
	Tracks  []captionLine `xml:"text"`
}

type captionLine struct {
	Text string `xml:",chardata"`
}

// Fetcher defines behavior to fetch transcripts for a video.
type Fetcher interface {
	Get(ctx context.Context, videoID string) (*Transcript, error)
}

// DefaultFetcher implements Fetcher using YouTube timedtext endpoint.
type DefaultFetcher struct{}

func (DefaultFetcher) Get(ctx context.Context, videoID string) (*Transcript, error) {
	if strings.TrimSpace(videoID) == "" {
		return nil, fmt.Errorf("empty videoID")
	}

	// Try cache first
	if tr, ok := readFromCache(videoID); ok {
		return tr, nil
	}

	langs := os.Getenv("YTMINER_TRANSCRIPT_LANGS")
	if strings.TrimSpace(langs) == "" {
		langs = "en,pt"
	}
	preferred := splitAndTrim(langs)

	// Try manual languages first
	for _, lang := range preferred {
		tr, err := fetchTimedText(ctx, videoID, lang, false)
		if err == nil && tr != nil && strings.TrimSpace(tr.Text) != "" {
			writeToCache(tr)
			return tr, nil
		}
	}
	// Fallback to auto-generated if available
	for _, lang := range preferred {
		tr, err := fetchTimedText(ctx, videoID, lang, true)
		if err == nil && tr != nil && strings.TrimSpace(tr.Text) != "" {
			writeToCache(tr)
			return tr, nil
		}
	}

	return nil, fmt.Errorf("no transcript available for video %s in languages %v", videoID, preferred)
}

func fetchTimedText(ctx context.Context, videoID string, lang string, auto bool) (*Transcript, error) {
	base := "https://www.youtube.com/api/timedtext"
	q := url.Values{}
	q.Set("v", videoID)
	q.Set("lang", lang)
	if auto {
		q.Set("kind", "asr")
	}
	endpoint := fmt.Sprintf("%s?%s", base, q.Encode())

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)
	if err != nil {
		return nil, err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()

	// Check for YouTube's "automated queries" block
	if resp.StatusCode == 403 {
		return nil, fmt.Errorf("transcript endpoint blocked by YouTube (automated queries detected)")
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("timedtext status %d", resp.StatusCode)
	}

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	if len(bytes) == 0 {
		return nil, fmt.Errorf("empty timedtext response")
	}

	// Check if response is HTML (indicates blocking)
	responseText := string(bytes)
	if strings.Contains(responseText, "<html>") || strings.Contains(responseText, "Sorry...") {
		return nil, fmt.Errorf("transcript endpoint blocked by YouTube (HTML response received)")
	}

	var parsed timedTextResponse
	if err := xml.Unmarshal(bytes, &parsed); err != nil {
		return nil, err
	}

	var sb strings.Builder
	for _, line := range parsed.Tracks {
		text := strings.TrimSpace(line.Text)
		if text == "" {
			continue
		}
		text = htmlEntityDecode(text)
		sb.WriteString(text)
		sb.WriteString(" ")
	}

	return &Transcript{
		VideoID:          videoID,
		Language:         lang,
		Source:           "timedtext",
		HasAutoGenerated: auto,
		Text:             strings.TrimSpace(sb.String()),
		FetchedAt:        time.Now(),
	}, nil
}

func splitAndTrim(s string) []string {
	parts := strings.Split(s, ",")
	out := make([]string, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			out = append(out, p)
		}
	}
	return out
}

func htmlEntityDecode(s string) string {
	replacer := strings.NewReplacer(
		"&amp;", "&",
		"&lt;", "<",
		"&gt;", ">",
		"&#39;", "'",
		"&quot;", "\"",
	)
	return replacer.Replace(s)
}

// Simple file cache in .cache/transcripts/{videoID}.{lang}.txt
func cachePath(videoID, lang string) string {
	base := os.Getenv("YTMINER_CACHE_DIR")
	if strings.TrimSpace(base) == "" {
		base = ".cache/transcripts"
	} else {
		base = fmt.Sprintf("%s/transcripts", strings.TrimRight(base, "/"))
	}
	_ = os.MkdirAll(base, 0755)
	return fmt.Sprintf("%s/%s.%s.txt", base, videoID, lang)
}

func writeToCache(tr *Transcript) {
	if tr == nil || tr.VideoID == "" || tr.Language == "" || tr.Text == "" {
		return
	}
	path := cachePath(tr.VideoID, tr.Language)
	_ = os.WriteFile(path, []byte(tr.Text), 0644)
}

func readFromCache(videoID string) (*Transcript, bool) {
	langs := os.Getenv("YTMINER_TRANSCRIPT_LANGS")
	if strings.TrimSpace(langs) == "" {
		langs = "en,pt"
	}
	for _, lang := range splitAndTrim(langs) {
		b, err := os.ReadFile(cachePath(videoID, lang))
		if err == nil && len(b) > 0 {
			return &Transcript{VideoID: videoID, Language: lang, Source: "cache", Text: string(b), FetchedAt: time.Now()}, true
		}
	}
	return nil, false
}
