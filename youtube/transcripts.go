package youtube

import (
	"context"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"time"
)

// Transcript represents a parsed transcript text for a given video and language.
type Transcript struct {
	VideoID          string
	Language         string
	Source           string // "timedtext"
	HasAutoGenerated bool
	Text             string
	FetchedAt        time.Time
}

// timedTextResponse models minimal XML for YouTube timedtext.
type timedTextResponse struct {
	XMLName xml.Name      `xml:"transcript"`
	Tracks  []captionLine `xml:"text"`
}

type captionLine struct {
	Text string `xml:",chardata"`
}

// GetTranscript tries to fetch transcript for a video using YouTube timedtext endpoint.
// It attempts preferred languages from YTMINER_TRANSCRIPT_LANGS env (comma-separated, e.g., "en,pt,es").
// Returns the first successful transcript or an error if none could be fetched.
func (c *Client) GetTranscript(ctx context.Context, videoID string) (*Transcript, error) {
	langs := os.Getenv("YTMINER_TRANSCRIPT_LANGS")
	if strings.TrimSpace(langs) == "" {
		langs = "en,pt"
	}
	preferred := splitAndTrim(langs)

	// Try manual languages first
	for _, lang := range preferred {
		tr, err := fetchTimedText(ctx, videoID, lang, false)
		if err == nil && tr != nil && strings.TrimSpace(tr.Text) != "" {
			return tr, nil
		}
	}
	// Fallback to auto-generated if available
	for _, lang := range preferred {
		tr, err := fetchTimedText(ctx, videoID, lang, true)
		if err == nil && tr != nil && strings.TrimSpace(tr.Text) != "" {
			return tr, nil
		}
	}

	return nil, fmt.Errorf("no transcript available for video %s in languages %v", videoID, preferred)
}

func fetchTimedText(ctx context.Context, videoID string, lang string, auto bool) (*Transcript, error) {
	base := "https://www.youtube.com/api/timedtext"
	q := url.Values{}
	q.Set("v", videoID)
	q.Set("lang", lang)
	if auto {
		q.Set("kind", "asr")
	}
	endpoint := fmt.Sprintf("%s?%s", base, q.Encode())

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, endpoint, nil)
	if err != nil {
		return nil, err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("timedtext status %d", resp.StatusCode)
	}

	bytes, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}

	// Empty means not found for that lang/kind
	if len(bytes) == 0 {
		return nil, fmt.Errorf("empty timedtext response")
	}

	var parsed timedTextResponse
	if err := xml.Unmarshal(bytes, &parsed); err != nil {
		return nil, err
	}

	var sb strings.Builder
	for _, line := range parsed.Tracks {
		text := strings.TrimSpace(line.Text)
		if text == "" {
			continue
		}
		// Replace HTML entities that may come in the payload
		text = htmlEntityDecode(text)
		sb.WriteString(text)
		sb.WriteString(" ")
	}

	return &Transcript{
		VideoID:          videoID,
		Language:         lang,
		Source:           "timedtext",
		HasAutoGenerated: auto,
		Text:             strings.TrimSpace(sb.String()),
		FetchedAt:        time.Now(),
	}, nil
}

func splitAndTrim(s string) []string {
	parts := strings.Split(s, ",")
	out := make([]string, 0, len(parts))
	for _, p := range parts {
		p = strings.TrimSpace(p)
		if p != "" {
			out = append(out, p)
		}
	}
	return out
}

// Minimal HTML entity decode for common entities present in timedtext payloads.
func htmlEntityDecode(s string) string {
	replacer := strings.NewReplacer(
		"&amp;", "&",
		"&lt;", "<",
		"&gt;", ">",
		"&#39;", "'",
		"&quot;", "\"",
	)
	return replacer.Replace(s)
}
